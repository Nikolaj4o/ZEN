use crate::read_inputs::*;
use crate::vanilla::*;
use r1cs_core::*;

#[test]
fn shallownet() {
    //let (x, l1_mat, l2_mat): (Vec<u8>, Vec<Vec<u8>>, Vec<Vec<u8>>) = read_shallownet_inputs_u8();
    //let x: Vec<u8> = read_vector1d("pretrained_model/shallownet/X_q.txt".to_string(), 784); // only read one image
    let x: Vec<Vec<u8>> =
        read_vector2d("pretrained_model/shallownet/X_q.txt".to_string(), 1000, 784);

    //y is the real output generated by pytorch code
    let y: Vec<Vec<u8>> = read_vector2d(
        "pretrained_model/shallownet/l2_output_q.txt".to_string(),
        1000,
        10,
    );

    let l1_mat: Vec<Vec<u8>> = read_vector2d(
        "pretrained_model/shallownet/l1_weight_q.txt".to_string(),
        128,
        784,
    );
    let l2_mat: Vec<Vec<u8>> = read_vector2d(
        "pretrained_model/shallownet/l2_weight_q.txt".to_string(),
        10,
        128,
    );
    let x_0: Vec<u8> = read_vector1d("pretrained_model/shallownet/X_z.txt".to_string(), 1);
    let l1_output_0: Vec<u8> =
        read_vector1d("pretrained_model/shallownet/l1_output_z.txt".to_string(), 1);
    let l2_output_0: Vec<u8> =
        read_vector1d("pretrained_model/shallownet/l2_output_z.txt".to_string(), 1);
    let l1_mat_0: Vec<u8> =
        read_vector1d("pretrained_model/shallownet/l1_weight_z.txt".to_string(), 1);
    let l2_mat_0: Vec<u8> =
        read_vector1d("pretrained_model/shallownet/l2_weight_z.txt".to_string(), 1);

    let l1_mat_multiplier: Vec<f32> = read_vector1d_f32(
        "pretrained_model/shallownet/l1_weight_s.txt".to_string(),
        128,
    );
    let l2_mat_multiplier: Vec<f32> = read_vector1d_f32(
        "pretrained_model/shallownet/l2_weight_s.txt".to_string(),
        10,
    );

    for i in 0..x.len() {
        let z: Vec<u8> = full_circuit_forward_u8(
            x[i].clone(),
            l1_mat.clone(),
            l2_mat.clone(),
            x_0[0],
            l1_output_0[0],
            l2_output_0[0],
            l1_mat_0[0],
            l2_mat_0[0],
            l1_mat_multiplier.clone(),
            l2_mat_multiplier.clone(),
        );
        // the rust forward and python forward result vectors shall be exactly the same.
        assert_eq!(z.clone(), y[i].clone());
    }
}
